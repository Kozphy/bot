{
    "sourceFile": "cmd/arguments.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1651888226287,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1651888226287,
            "name": "Commit-0",
            "content": "\"\"\"\nThis module contains the argument manager class\n\"\"\"\n\nimport argparse\nfrom functools import partial\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\nimport logging\n# from bot.constants import CONFIG\nfrom bot.cmd.cli_option import (AVAILABLE_CLI_OPTIONS, ARGS_COMMON, ARGS_TRADE,\n SYNC_ARGS, ARGS_COMMON_OPTIMIZE)\n\n\n# NO_CONFIG_REQUIRED = ['sync']\n\n## position argument\nPOSITION_ARGS = ['trade', 'backtesting', 'sync']\n\nlogger = logging.getLogger(__name__)\n\nclass Arguments:\n    \"\"\"\n    Arguments Class. Manage the arguments received by the cli\n    \"\"\"\n    \n    def __init__(self, args: Optional[List[str]]) -> None:\n        self.args = args\n        self._parsed_arg: Optional[argparse.Namespace] = None\n    \n    def get_parsed_arg(self) -> Dict[str, Any]:\n        \"\"\"\n        Return the list of arguments\n        :return: List[str]  List of arguments\n        \"\"\"\n        if self._parsed_arg is None:\n            self.parser = argparse.ArgumentParser(description='trading bot', prog='short_bot')\n            self._build_subcommands()\n            self._parsed_arg = self._parse_args()\n        \n        return vars(self._parsed_arg)\n    \n\n    def _parse_args(self) -> argparse.Namespace:\n        \"\"\"\n        Parses cli interface given arguments and returns an argparse Namespace instance.\n        \"\"\"\n        logging.debug('load cli interface arguments to namespace object')\n\n        parsed_arg = self.parser.parse_args(self.args)\n\n        return parsed_arg\n\n    \n    def _build_args(self, optionlist, parser, positionlist = None):\n\n        if positionlist is None: \n            for val in optionlist: \n                if hasattr(parser, 'title'):\n                    logging.debug(f'create {val} arguments string to {parser.title} parser')\n                elif hasattr(parser, 'prog'):\n                    logging.debug(f'create {val} arguments string to {parser.prog} parser')\n                opt = AVAILABLE_CLI_OPTIONS[val]\n                parser.add_argument(*opt.cli, dest=val, **opt.kwargs)\n\n\n    def _build_subcommands(self) -> None:\n        \"\"\"\n        Builds and attaches all subcommands.\n        :return None\n        \"\"\"\n        logging.debug('build_subcommands')\n\n        # Build option arguments (as group Common Options)\n        _common_parser = argparse.ArgumentParser(add_help=False)\n        group = _common_parser.add_argument_group(\"Common arguments\")\n        self._build_args(optionlist=ARGS_COMMON, parser=group)\n        # _common_parser.print_help()\n\n        # Build command into self.parser\n        self._build_args(optionlist=['version'], parser=self.parser)\n\n        ## build subcommand\n        subparsers = self.parser.add_subparsers(dest='command')\n\n        from bot.cmd import (start_trade, start_sync)\n\n        # build trade command and options\n        trade_cmd = subparsers.add_parser('trade', help='activate trade mode',\n                                            parents=[_common_parser])\n        self._build_args(optionlist=ARGS_TRADE, parser=trade_cmd)\n        trade_cmd.set_defaults(func=start_trade)\n        # trade.add_argument('bar', help='trade mode')\n\n        # build sync command and options\n        sync_cmd = subparsers.add_parser('sync', help='download data and let it store in sql',\n                                        parents=[_common_parser])\n        self._build_args(optionlist=SYNC_ARGS, parser=sync_cmd)\n        sync_cmd.set_defaults(func=start_sync)"
        }
    ]
}